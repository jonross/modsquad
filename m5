#!/usr/bin/python

from collections import deque, namedtuple
from funcy import silent
from multiprocessing import Process, Pipe
import os
import re
import subprocess as sub
import sys

Options = namedtuple("Options", "splitter joiner")

def main(args):

    args = deque(args)
    actions = []
    inputfiles = []
    options = Options(re.compile(r"\s+"), " ")
    smallinput = False

    def getargs(action, count, converter):
        """On behalf of action, pop count from args and convert using converter.
        Converter should return None on failure.
        """
        if len(args) < count:
            die("Action '%s' needs %d args but %d given" % (action, count, len(args)))
        myargs = [args.popleft() for _ in range(count)]
        for i, arg in enumerate(myargs):
            converted = converter(arg)
            if converted is None:
                die("Arg '%s' to action '%s' not of expected type" % (arg, action))
            myargs[i] = converted
        return myargs

    # Process args.  When done, actions will a list of actor name / args tuples e.g.
    #   [("grep", ["*.java"]),
    #    ("head", [20]),
    #    ]

    while len(args) > 0:
        action = args.popleft()
        if "." in action:
            inputfiles.append(action)
        elif action == "all":
            someinput = False
        elif action == "head":
            actions.append(("head", getargs("head", 1, silent(int))))
        elif action == "some":
            someinput = True
        elif action == "tail":
            actions.append(("tail", getargs("tail", 1, silent(int))))
        else:
            die("No action named '" + action + "'")

    if len(actions) == 0:
        die("No actions specified")

    # The first pipeline actor is the file reader; it has different args from
    # the other actors.

    inbound, outbound = Pipe()
    reader = Process(target=read_inputs, args=(outbound, inputfiles, smallinput))
    reader.start()

    for actor, args in actions:
        nextinbound, outbound = Pipe()
        process = Process(target=start, args=(actor, args, inbound, outbound))
        process.start()
        inbound = nextinbound

    try:
        while True:
            chunk = inbound.recv()
            for line in chunk:
                print line
    except EOFError:
        pass

def read_inputs(conn, filenames, smallinput):

    """Specially launched actor at the start of the pipeline; read files or
    standard input."""

    output = WriteChannel(conn)

    def read_input(stream):
        number = 0
        for line in stream:
            if not smallinput or number <= 1000:
                output((number, line, []))
            number += 1

    if len(filenames) == 0:
        read_input(sys.stdin)
    else:
        for filename in (filenames[:3] if smallinput else filenames):
            with open_file(filename) as file:
                read_input(file)

    output.flush()

def start(actor, args, inbound, outbound):

    """Toehold for per-process action.
    Creates read / write channels around pipe."""

    actor = globals()[actor]
    input = ReadChannel(inbound)
    output = WriteChannel(outbound)
    args = args + [input, output]
    actor(*args)

####################################################################################################

class WriteChannel:

    """Wraps the write end of a Pipe; sends metadata first, and sends lines in chunks to
    reduce the number of system calls."""

    def __init__(self, conn, metadata=None):
        self.conn = conn
        # self.lines = [metadata]
        self.lines = []

    def __call__(self, line):
        if len(self.lines) == 100:
            self.conn.send(self.lines)
            self.lines = [line]
        else:
            self.lines.append(line)

    def flush(self):
        if len(self.lines) > 0:
            self.conn.send(self.lines)
            self.lines = []

class ReadChannel:

    """Wraps the read end of a Pipe; receives metadata first, and reads lines in chunks to
    reduce the number of system calls."""

    def __init__(self, conn):
        self.conn = conn
        self.lines = iter([])
        self.metadata = None
        self.eof = False

    def __iter__(self):
        # self.metadata = self._receive()
        return self

    def next(self):
        if self.eof:
            raise StopIteration
        try:
            print "Returning a line"
            return self.lines.next()
        except StopIteration:
            lines = self._receive()
            print "Read", len(lines), "lines"
            if lines:
                self.lines = iter(lines)
            return self.next()

    def close(self):
        self.conn.close()

    def _receive(self):
        try:
            return self.conn.recv()
        except EOFError:
            print "ReadChannel EOF"
            self.eof = True
            return None

####################################################################################################

def drop(numlines, input, output):
    count = numlines
    for line in input:
        if count == 0:
            return
        output(line)
        count -= 1

def head(numlines, input, output):
    count = 0
    for line in input:
        if count == numlines:
            return
        output(line)
        count += 1
    output.close()

def grep(pattern, input, output):
    pattern = re.compile(pattern)
    for line in input:
        if pattern.search(input.unsplit(line)[1]):
            output(line)

def tail(numlines, input, output):
    queue = deque()
    for line in input:
        if len(queue) == numlines:
            queue.popleft()
        queue.append(line)
    for line in queue:
        output(line)

####################################################################################################

class Columns:

    """A numbered list of columns, starting at zero internally, but parsed
    from a cut(1)-style list e.g. 1,4-6,8-"""

    def __init__(self, expr):
        self.ranges = []
        self.aslist = []
        self.aslistmax = 0
        for span in expr.split(","):
            if "-" not in span:
                span = span + "-" + span
            start, end = span.split("-", 1)
            start = 0 if start == "" else int(start) - 1
            end = (1<<31)-1 if end == "" else int(end) - 1
            self.ranges.append([start,end])

    def has(self, index):
        for r in self.ranges:
            if index >= r[0] and index <= r[1]:
                return True
        return False

    def listed(self, count):
        if self.aslistmax < count:
            self.aslist = []
            for index in range(count):
                if self.has(index):
                    self.aslist.append(index)
            self.aslistmax = count
        return self.aslist

def open_file(filename):
    if filename.endswith(".gz"):
        return sub.Popen(["gunzip", "-c", filename], stdout=sub.PIPE).stdout
    elif filename.endswith(".Z"):
        return os.popen("zcat <" + filename)
    else:
        return open(filename)

def die(message):
    sys.stderr.write(message + "\n")
    sys.exit(1)

####################################################################################################

if __name__ == "__main__":
    main(sys.argv[1:])

