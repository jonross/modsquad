#!/usr/bin/env python2.7

import collections as co
import re
import sys

NUMBER = re.compile("^\d+$")
RANGE = re.compile("^(\d+)-(\d*)$")

Step = co.namedtuple("Step", "fn name names argspecs")

STEPS = {}

####################################################################################################
#
# Driver

def main(args):
    args = co.deque(args)
    def readinput():
        for num, line in enumerate(sys.stdin):
            yield num, line.rstrip()
    input = Reader(readinput())
    while len(args) > 0:
        stepname = args.popleft()
        step = STEPS.get(stepname) or die("Unknown step name: " + stepname)
        stepargs = parse(args, step.argspecs)
        input = Reader(step.fn(None, input, *stepargs))
    for num, line in input.lines:
        print line

class Reader:
    def __init__(self, input):
        self.items = input
        self.lines = self.readlines(input)
        self.rows = self.readrows(input)
    def readlines(self, input):
        for num, line in input:
            # print "RL yielding", line
            if type(line) == str:
                yield num, line
            else:
                yield num, "\t".join(line)
    def readrows(self, input):
        for num, line in input:
            # print "RR yielding", line
            if type(line) == list:
                yield num, line
            elif "\t" in line:
                yield num, line.split("\t")
            else:
                yield num, line.split()

####################################################################################################
#
# Arg parsers

ArgSpec = co.namedtuple("ArgSpec", "function docstring optional")

def parse(argq, argspecs):
    def parseone(spec):
        if len(argq) > 0:
            return spec.function(argq.popleft())
        return None if spec.optional else die("Missing argument, expected " + spec.docstring)
    return filter(notnone, map(parseone, argspecs))

def oneof(docstring, choices):
    def parse(arg):
        return arg if arg in choices else None
    return ArgSpec(parse, docstring, false)

def columns(docstring="column expression"):
    def parse(arg):
        return Columns.from_string(arg)
    return ArgSpec(parse, docstring, False)

def cast(function, docstring):
    def parse(arg):
        try:
            return function(arg)
        except:
            die("Expected " + docstring + " but got: " + arg)
    return ArgSpec(parse, docstring, False)

def optional(spec):
    return ArgSpec(spec.function, spec.docstring, True)

def number(arg):
    if "," in arg:
        arg = arg.translate(None, ",")
    if "." in arg or "e" in arg:
        return float(arg)
    return int(arg)

####################################################################################################
#
# Step definitions

def step(name, args):
    names = name if type(name) == list else [name]
    def wrap(f):
        step = Step(f, names[0], names, args)
        for name in names:
            STEPS[name] = step
        return f
    return wrap

@step(name="strip", args=[cast(str, "characters to remove")])
def strip(meta, input, chars):
    for num, row in input.rows:
        yield num, map(lambda cell: cell.translate(None, chars))

@step(name=["head"], args=[cast(int, "number of lines")])
def head(meta, input, count):
    if count <= 0:
        return
    for num, item in input.items:
        if count <= 0:
            return
        yield num, item
        count -= 1

@step(name=["tail"], args=[cast(int, "number of lines")])
def tail(meta, input, count):
    if count <= 0:
        return
    queue = co.deque()
    for num, item in input.items:
        if len(queue) == count:
            queue.popleft()
        queue.append((num, item))
    for num, item in queue:
        yield num, item

@step(name=["headtail", "ht"], args=[])
def headtail(meta, input):
    count = 0
    queue = co.deque()
    for num, item in input.items:
        count += 1
        if count <= 10:
            yield num, item
        else:
            if len(queue) == 10:
                queue.popleft()
            queue.append((num, item))
    if len(queue) > 0:
        yield 0, "--"
        for num, item in queue:
            yield num, item

@step(name="keep", args=[columns()])
def keep(meta, input, columns):
    for num, row in input.rows:
        newrow = []
        for index in columns.list:
            if index < len(row):
                newrow.append(row[index])
        if columns.rest:
            for index in range(columns.rest, len(row)):
                newrow.append(row[index])
        yield num, newrow

####################################################################################################
#
# Misc utils

class Columns:

    def __init__(self, list, rest):
        self.list, self.rest = list, rest

    @staticmethod
    def from_string(s):
        c = Columns([], None)
        for part in s.replace("c", "").split(","):
            if NUMBER.match(part):
                c.list.append(int(part)-1)
            else:
                m = RANGE.match(part) or die("Bad column expression: " + part)
                if m.group(2) != "":
                    c.list += [x for x in range(int(m.group(1)) - 1, int(m.group(2)))]
                elif c.rest is None or int(m.group(1)) - 1 < c.rest:
                    c.rest = int(m.group(1)) - 1
        return c

def notnone(x): return x is not None

def die(message):
    sys.stderr.write(message + "\n")
    sys.exit(1)

####################################################################################################

main(sys.argv[1:])

