#!/usr/bin/env python2.7

import collections as co
import re
import sys

NUMBER = re.compile("^\d+$")
RANGE = re.compile("^(\d+)-(\d*)$")

Step = co.namedtuple("Step", "fn name names argspecs")

SEPS = {
    "ss" : " ",  "ssv" : " ",
    "cs" : ",",  "csv" : ",",
    "ps" : "|",  "psv" : "|",
    "ts" : "\t", "tsv" : "\t"
}

STEPS = {}

####################################################################################################
#
# Driver

def main(args):

    def readinput():
        for num, line in enumerate(sys.stdin):
            yield num, line.rstrip()

    # With no args, re-split the input, which generally will normalize whitespace
    # separation to tabs.

    if len(args) == 0:
        args = ["split"]
    args = co.deque(args)
    meta = Metadata()
    input = None

    while len(args) > 0:

        # Handle special names for changing field separator

        stepname = args.popleft()
        sep = SEPS.get(stepname)
        if sep is not None:
            meta.set_separator(sep)
            continue

        # Find step by name and parse the args.  Note we don't create the initial
        # input until it's actually needed; this ensures that if a field separator
        # is specified early on, it's in the input reader metadata.

        step = STEPS.get(stepname) or die("Unknown step name: " + stepname)
        stepargs = parse(args, step.argspecs)
        input = input or Reader(meta, readinput())
        input = Reader(meta, step.fn(None, input, *stepargs))

    for num, line in input.lines:
        print line

class Metadata:

    """
    Input / output behaviors that persist across individual data transformation
    steps.

    insep - input separator; " " means any span of whitespace
    outsep - output separator, same as insep but "\t" if insep is None
    splitter - for splitting on insep, or None if insep is None
    """

    def __init__(self, sep=None):
        self.set_separator(sep)

    def set_separator(self, sep):
        self.insep = sep
        self.outsep = sep or "\t"
        # The splitter is distinct from self.insep because if the separator is a space,
        # we want to split on whitespace, not just one space.
        if sep is None:
            self.splitter = None
        elif sep == " ":
            self.splitter = lambda s: s.split(None)
        else:
            self.splitter = lambda s: s.split(sep)

class Reader:

    """
    Abstracts iteration over numbered lines or rows.  Callers use either
        for num, line in reader.lines: ...
    or
        for num, row in reader.rows: ...
    """

    def __init__(self, meta, input):
        self.meta = meta
        self.items = input
        self.lines = self.readlines(input)
        self.rows = self.readrows(input)

    def readlines(self, input):
        """
        Read input as lines; if lines have already been split to rows,
        join them on the current output separator.
        """
        outsep = self.meta.outsep
        for num, line in input:
            if type(line) == str:
                yield num, line
            else:
                yield num, outsep.join(line)

    def readrows(self, input):
        """
        Reads input as rows; if lines have not yet been split to rows,
        split them on the current input separator.  If not has been set, guess.
        """
        for num, line in input:
            if type(line) == list:
                yield num, line
            elif self.meta.splitter:
                yield num, self.meta.splitter(line)
            else:
                head = [(num, line)]
                for num, line in input:
                    head.append((num, line))
                    if len(head) == 10:
                        break
                self.meta.set_separator(guess_separator(map(second, head)))
                for num, line in head:
                    yield num, self.meta.splitter(line)

def guess_separator(lines):
    """
    Guess the correct input field separator given a sample of lines.
    If the same nonzero number of tabs is present on each, use tab.
    Otherwise use the one of (whitespace, comma, pipe) that appears
    most frequently.
    """
    def occurrences(line, sep): 
        if sep == " ":
            return line.count(" ") + line.count("\t")
        else:
            return line.count(sep)
    ntabs = [occurrences(line, "\t") for line in lines]
    if ntabs[0] > 0 and all(map(lambda n: n == ntabs[0], ntabs)):
        return "\t"
    counts = [[(occurrences(line, sep), sep) for sep in " ,|"] for line in lines]
    bests = [second(max(c, key=first)) for c in counts]
    best = first(first(co.Counter(bests).most_common(1)))
    # print >>sys.stderr, "The best separator is", best
    return best

####################################################################################################
#
# Arg parsers

ArgSpec = co.namedtuple("ArgSpec", "function docstring optional")

def parse(argq, argspecs):
    def parseone(spec):
        if len(argq) > 0:
            return spec.function(argq.popleft())
        return None if spec.optional else die("Missing argument, expected " + spec.docstring)
    return filter(notnone, map(parseone, argspecs))

def oneof(docstring, choices):
    def parse(arg):
        return arg if arg in choices else None
    return ArgSpec(parse, docstring, false)

def columns(docstring="column expression"):
    def parse(arg):
        return Columns.from_string(arg)
    return ArgSpec(parse, docstring, False)

def cast(function, docstring):
    def parse(arg):
        try:
            return function(arg)
        except:
            die("Expected " + docstring + " but got: " + arg)
    return ArgSpec(parse, docstring, False)

def optional(spec):
    return ArgSpec(spec.function, spec.docstring, True)

def number(arg):
    if "," in arg:
        arg = arg.translate(None, ",")
    if "." in arg or "e" in arg:
        return float(arg)
    return int(arg)

####################################################################################################
#
# Step definitions

def step(name, args):
    names = name if type(name) == list else [name]
    def wrap(f):
        step = Step(f, names[0], names, args)
        for name in names:
            STEPS[name] = step
        return f
    return wrap

@step(name="strip", args=[cast(str, "characters to remove")])
def strip(meta, input, chars):
    for num, row in input.rows:
        yield num, map(lambda cell: cell.translate(None, chars))

@step(name=["head"], args=[cast(int, "number of lines")])
def head(meta, input, count):
    if count <= 0:
        return
    for num, item in input.items:
        if count <= 0:
            return
        yield num, item
        count -= 1

@step(name=["tail"], args=[cast(int, "number of lines")])
def tail(meta, input, count):
    if count <= 0:
        return
    queue = co.deque()
    for num, item in input.items:
        if len(queue) == count:
            queue.popleft()
        queue.append((num, item))
    for num, item in queue:
        yield num, item

@step(name=["headtail", "ht"], args=[])
def headtail(meta, input):
    count = 0
    queue = co.deque()
    for num, item in input.items:
        count += 1
        if count <= 10:
            yield num, item
        else:
            if len(queue) == 10:
                queue.popleft()
            queue.append((num, item))
    if len(queue) > 0:
        yield 0, "--"
        for num, item in queue:
            yield num, item

@step(name="keep", args=[columns()])
def keep(meta, input, columns):
    for num, row in input.rows:
        newrow = []
        for index in columns.list:
            if index < len(row):
                newrow.append(row[index])
        if columns.rest is not None:
            for index in range(columns.rest, len(row)):
                newrow.append(row[index])
        yield num, newrow

@step(name="drop", args=[columns()])
def drop(meta, input, columns):
    todrop = set(columns.list)
    for num, row in input.rows:
        newrow = []
        for index in range(0, len(row)):
            if index in todrop:
                continue
            if columns.rest is not None and index >= columns.rest:
                continue
            newrow.append(row[index])
        if len(newrow) > 0:
            yield num, newrow

@step(name="split", args=[])
def split(meta, input):
    for num, row in input.rows:
        yield num, row

####################################################################################################
#
# Misc utils

class Columns:

    def __init__(self, list, rest):
        self.list, self.rest = list, rest

    @staticmethod
    def from_string(s):
        c = Columns([], None)
        for part in s.replace("c", "").split(","):
            if NUMBER.match(part):
                c.list.append(int(part)-1)
            else:
                m = RANGE.match(part) or die("Bad column expression: " + part)
                if m.group(2) != "":
                    c.list += [x for x in range(int(m.group(1)) - 1, int(m.group(2)))]
                elif c.rest is None or int(m.group(1)) - 1 < c.rest:
                    c.rest = int(m.group(1)) - 1
        return c

def notnone(x): return x is not None

def die(message):
    sys.stderr.write(message + "\n")
    sys.exit(1)

def first(x): return x[0]
def second(x): return x[1]

####################################################################################################

main(sys.argv[1:])

